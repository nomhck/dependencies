<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<title>DAG Linker (Highlight relatives on selection)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  /* ===== åŸºæœ¬ãƒ†ãƒ¼ãƒ ===== */
  :root { --bg:#f9fbfd; --fg:#0f172a; --muted:#64748b; --accent:#06b6d4; --danger:#ef4444; --ok:#10b981; --edge:#94a3b8; }
  body { margin:0; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto; background:var(--bg); color:var(--fg); }
  header { padding: 12px 16px; border-bottom:1px solid #e2e8f0; background:white; position:sticky; top:0; z-index:10;}
  header h1 { margin:0; font-size:18px; }

  /* ===== ãƒ„ãƒ¼ãƒ«ãƒãƒ¼ ===== */
  .toolbar { display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap; }
  .toolbar input[type="text"], .toolbar select { padding:6px 8px; border:1px solid #cbd5e1; border-radius:8px; min-width:160px;}
  .toolbar button { padding:6px 10px; border-radius:8px; border:1px solid #cbd5e1; background:white; cursor:pointer;}
  .toolbar button.primary { background:var(--accent); border-color:var(--accent); color:white; }
  .toolbar button.danger { background:var(--danger); border-color:var(--danger); color:white;}

  /* ===== ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆï¼šå·¦å³ã®å€™è£œ + å³å´æƒ…å ± ===== */
  .container { display:grid; grid-template-columns: 1fr 1fr 1.2fr; gap:12px; padding:12px; }
  .panel { background:white; border:1px solid #e2e8f0; border-radius:12px; overflow:hidden; display:flex; flex-direction:column; min-height:300px; }
  .panel h2 { font-size:14px; margin:0; padding:10px 12px; border-bottom:1px solid #e2e8f0; background:#f8fafc; display:flex; gap:8px; align-items:center; }
  .list { overflow:auto; padding:8px; display:flex; flex-direction:column; gap:6px; }

  /* ===== å€™è£œã‚«ãƒ¼ãƒ‰ ===== */
  .item { padding:8px 10px; border:1px solid #e5e7eb; border-radius:8px; background:#fff; user-select:none; touch-action:none; display:flex; justify-content:space-between; align-items:center; gap:8px;}
  .item .meta { font-size:11px; color:var(--muted);}
  .item .ops { display:flex; gap:6px; }
  .item button.icon { border:1px solid #cbd5e1; background:#fff; border-radius:8px; padding:2px 6px; font-size:12px; cursor:pointer; }
  .item.drag-parent { cursor:grab; }
  .item.drag-parent:active { cursor:grabbing; }
  .drop-ready .item { outline: 2px dashed #cbd5e1; }
  .drop-target { outline:2px dashed var(--accent); background: #ecfeff; }

  /* ===== ä¾å­˜ãƒ†ãƒ¼ãƒ–ãƒ« ===== */
  .edges { overflow:auto; }
  table { width:100%; border-collapse: collapse; font-size:13px; }
  th, td { border-bottom:1px solid #f1f5f9; padding:8px; text-align:left; }

  /* ===== è£œåŠ©UI ===== */
  .pill { display:inline-block; padding:2px 6px; border-radius:999px; background:#f1f5f9; }
  .mermaid-box { padding:8px; background:#0b1020; color:#e2e8f0; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; white-space:pre; overflow:auto; font-size:12px; border-top:1px solid #1f2937;}
  .addbar { display:flex; gap:8px; align-items:center; padding:8px 0; flex-wrap:wrap; }
  details.bulk { background:#f8fafc; border:1px dashed #cbd5e1; border-radius:10px; padding:8px 10px; }
  details.bulk textarea { width:100%; min-height:120px; padding:8px; border:1px solid #cbd5e1; border-radius:8px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }

  /* ===== SVGæç”»ã‚¨ãƒªã‚¢ ===== */
  .render-toolbar { padding:8px 12px; border-bottom:1px solid #e2e8f0; display:flex; gap:8px; flex-wrap:wrap; align-items:center; background:#fafafa;}
  .canvasWrap { position:relative; height:520px; background:#ffffff; }
  svg#graphSvg { width:100%; height:100%; cursor:grab; }
  svg#graphSvg:active { cursor:grabbing; }
  .legend { margin-left:auto; font-size:12px; color:var(--muted); }

  /* ===== ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¾ ===== */
  .dim { opacity: 0.18; transition: opacity .15s ease; }       /* éå¯¾è±¡ã¯æ·¡ã */
  .hi-node { stroke:#0ea5e9 !important; stroke-width:2 !important; } /* å¯¾è±¡ãƒãƒ¼ãƒ‰æ  */
  .hi-center { stroke:#ef4444 !important; stroke-width:2.5 !important; } /* ä¸­å¿ƒãƒãƒ¼ãƒ‰ */
  .hi-edge { stroke:#0ea5e9 !important; stroke-width:2 !important; opacity:0.95 !important; } /* å¯¾è±¡ã‚¨ãƒƒã‚¸ */
</style>
<!-- Mermaid: è‡ªå‹•ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚’å°å…¥ï¼ˆCDNï¼‰ã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯çŠ¶æ³ã§èª­ã¿è¾¼ã¿ã•ã‚Œãªã„å ´åˆã¯ç„¡è¦–ã•ã‚Œã‚‹ã‚ˆã†å®‰å…¨ã«æ‰±ã„ã¾ã™ -->
<script src="https://cdn.jsdelivr.net/npm/mermaid@10.4.0/dist/mermaid.min.js"></script>
<script>
try{ if(window.mermaid) mermaid.initialize({ startOnLoad:false }); }catch(e){ console.warn('mermaid init failed', e); }
</script>
</head>
<body>
  <header>
    <h1>ã™ã”ã„å·¥ç¨‹ç®¡ç†</h1>

    <!-- ===== å€™è£œï¼ˆãƒãƒ¼ãƒ‰ï¼‰è¿½åŠ ãƒãƒ¼ ===== -->
    <div class="addbar">
      <strong>å€™è£œã‚’è¿½åŠ :</strong>
      <input id="newId" type="text" placeholder="IDï¼ˆä»»æ„ã€‚æœªå…¥åŠ›ã¯è‡ªå‹•ï¼‰" />
      <input id="newLabel" type="text" placeholder="ãƒ©ãƒ™ãƒ«/è¦ç´ åï¼ˆä»»æ„ï¼‰" />
      <button id="addNodeBtn" class="primary">è¿½åŠ </button>
      <details class="bulk">
        <summary>ä¸€æ‹¬è¿½åŠ </summary>
        <div style="font-size:12px; color:var(--muted); margin:6px 0;">
          1è¡Œ=1ãƒãƒ¼ãƒ‰ã€‚<code>ID,Label</code> / <code>ID<TAB>Label</code> / <code>IDã®ã¿</code> ã«å¯¾å¿œã€‚
        </div>
        <textarea id="bulkText" placeholder="ä¾‹&#10;A,æ‹…å½“æ¥­å‹™A&#10;B,æ‹…å½“æ¥­å‹™B&#10;C,ãƒ¬ãƒ“ãƒ¥ãƒ¼"></textarea>
        <div style="display:flex; gap:8px; margin-top:8px;">
          <button id="bulkAddBtn">ä¸€æ‹¬è¿½åŠ </button>
          <button id="bulkClearBtn" class="danger">ã‚¯ãƒªã‚¢</button>
        </div>
      </details>
    </div>

    <!-- ===== ãƒ•ã‚£ãƒ«ã‚¿/å±¥æ­´/å…¥å‡ºåŠ› ===== -->
    <div class="toolbar">
      <input id="filterLeft" type="text" placeholder="å·¦(è¦ª)ã®çµã‚Šè¾¼ã¿â€¦" />
      <input id="filterRight" type="text" placeholder="å³(å­)ã®çµã‚Šè¾¼ã¿â€¦" />
      <button id="undoBtn">Undo</button>
      <button id="redoBtn">Redo</button>
      <button id="exportBtn" class="primary">Export JSON</button>
      <button id="importBtn">Import JSON</button>
      <input id="fileInput" type="file" accept="application/json" style="display:none" />
      <button id="clearBtn" class="danger">ã™ã¹ã¦ãƒªã‚»ãƒƒãƒˆ</button>
    </div>

    <!-- ===== ãƒã‚¤ãƒ©ã‚¤ãƒˆæ“ä½œãƒãƒ¼ï¼ˆæ–°è¦ï¼‰ ===== -->
    <div class="toolbar" style="margin-top:6px;">
      <strong>ãƒã‚¤ãƒ©ã‚¤ãƒˆ:</strong>
      <!-- datalistã§IDè£œå®Œ -->
      <input id="focusId" list="nodeList" placeholder="ä¸­å¿ƒIDï¼ˆä¾‹: Aï¼‰" />
      <datalist id="nodeList"></datalist>
      <select id="focusMode" title="å¯¾è±¡ç¯„å›²">
        <option value="both">ä¸¡æ–¹å‘ï¼ˆä¸Šæµ+ä¸‹æµï¼‰</option>
        <option value="up">ä¸Šæµï¼ˆç¥–å…ˆï¼‰</option>
        <option value="down">ä¸‹æµï¼ˆå­å­«ï¼‰</option>
        <option value="one">1-hopï¼ˆè¦ªã¨å­ï¼‰</option>
      </select>
      <label>æ·±ã•:
        <input id="focusDepth" type="number" min="1" step="1" placeholder="ç©º=å…¨åŸŸ" style="width:84px" />
      </label>
      <button id="applyFocusBtn">é©ç”¨</button>
      <button id="clearFocusBtn">ã‚¯ãƒªã‚¢</button>
      <span class="legend">â€»SVGä¸Šã®ãƒãƒ¼ãƒ‰ã‚’ã‚¯ãƒªãƒƒã‚¯ã§ã‚‚ãƒã‚¤ãƒ©ã‚¤ãƒˆã€‚Escã§è§£é™¤ã€‚</span>
    </div>
  </header>

  <!-- ===== å·¦å³å€™è£œ + ä¾å­˜è¡¨ ===== -->
  <div class="container">
    <section class="panel" id="leftPanel">
      <h2>è¦ªå€™è£œï¼ˆãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹ï¼‰</h2>
      <div id="leftList" class="list" aria-label="è¦ªå€™è£œä¸€è¦§"></div>
      <div class="render-toolbar" style="border-top:1px solid #e2e8f0; background:white;">
        å·¦ã®è¦ç´ ã‚’å³ã«ãƒ‰ãƒ­ãƒƒãƒ— â†’ <span class="pill">è¦ªâ†’å­</span> ã‚’è¿½åŠ 
      </div>
    </section>

    <section class="panel" id="rightPanel">
      <h2>å­å€™è£œï¼ˆãƒ‰ãƒ­ãƒƒãƒ—å…ˆï¼‰</h2>
      <div id="rightList" class="list" aria-label="å­å€™è£œä¸€è¦§"></div>
      <div class="render-toolbar" style="border-top:1px solid #e2e8f0; background:white;">
        ãƒ‰ãƒ­ãƒƒãƒ—å¯èƒ½ãªè¦ç´ ã¯ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤º
      </div>
    </section>

    <section class="panel">
      <h2>ä¾å­˜é–¢ä¿‚ï¼ˆç·¨é›†å¯èƒ½ï¼‰</h2>
      <div class="edges">
        <table>
          <thead>
            <tr><th>è¦ª</th><th>â†’</th><th>å­</th><th>çŠ¶æ…‹</th><th>æ“ä½œ</th></tr>
          </thead>
          <tbody id="edgeTable"></tbody>
        </table>
      </div>
      <div class="mermaid-box" id="mermaidTxt"></div>
      <div class="render-toolbar" style="border-top:1px solid #e2e8f0; background:white;">
        Mermaidã¯ <span class="pill">graph LR</span> ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’å‡ºåŠ›ï¼ˆæç”»ã¯ä»»æ„ç’°å¢ƒã§ï¼‰
      </div>
    </section>
  </div>

  <!-- ===== SVGæç”»ãƒ‘ãƒãƒ« ===== -->
  <section class="panel" style="margin: 0 12px 12px;">
    <div class="render-toolbar">
      <strong>ä¾å­˜ã‚°ãƒ©ãƒ•ï¼ˆSVGæç”»ï¼‰</strong>
      <label>æ–¹å‘:
        <select id="directionSel">
          <option value="LR">LRï¼ˆå·¦â†’å³ï¼‰</option>
          <option value="TB">TBï¼ˆä¸Šâ†’ä¸‹ï¼‰</option>
        </select>
      </label>
      <label>ãƒ«ãƒ¼ãƒˆå„ªå…ˆID:
        <input id="rootHint" type="text" placeholder="ä¾‹: S" style="width:120px;" />
      </label>
      <button id="fitBtn">Fit</button>
      <button id="exportSvgBtn">Export SVG</button>
      <span class="legend">ãƒ‘ãƒ³:ãƒ‰ãƒ©ãƒƒã‚° / ã‚ºãƒ¼ãƒ :ãƒ›ã‚¤ãƒ¼ãƒ«</span>
    </div>
    <div class="canvasWrap">
      <svg id="graphSvg">
        <defs>
          <!-- ã‚¨ãƒƒã‚¸çŸ¢å° -->
          <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse">
            <path d="M 0 0 L 10 5 L 0 10 z" fill="#94a3b8"></path>
          </marker>
        </defs>
      </svg>
    </div>
  </section>

<script>
(function(){
  /* ***************************************************************************
   * ã‚¢ãƒ—ãƒªçŠ¶æ…‹
   * -------------------------------------------------------------------------
   * state ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¯ã‚¢ãƒ—ãƒªå…¨ä½“ã®çŠ¶æ…‹ã‚’ä¿æŒã—ã¾ã™ã€‚
   * å„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å½¹å‰²ï¼š
   *  - nodes: Map ã‚’ä½¿ã£ã¦ãƒãƒ¼ãƒ‰ã‚’ç®¡ç†ï¼ˆã‚­ãƒ¼ã¯ idã€å€¤ã¯ {id,label}ï¼‰
   *  - edges: Set ã« "è¦ª|å­" ã®ã‚­ãƒ¼æ–‡å­—åˆ—ã‚’ä¿æŒï¼ˆé‡è¤‡é˜²æ­¢ã®ãŸã‚ï¼‰
   *  - history: æ“ä½œå±¥æ­´ï¼ˆUndo ç”¨ï¼‰
   *  - future: å…ƒã«æˆ»ã—ãŸæ“ä½œã®å±¥æ­´ï¼ˆRedo ç”¨ï¼‰
   *  - lastId: è‡ªå‹•æ¡ç•ªã®ãŸã‚ã«ç¾åœ¨ã®æœ€å¤§æ•°å€¤IDã‚’ä¿æŒ
   *  - direction: SVG ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®æ–¹å‘ ('LR' å·¦â†’å³ / 'TB' ä¸Šâ†’ä¸‹)
   *  - rootHint: ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆæ™‚ã®å„ªå…ˆãƒ«ãƒ¼ãƒˆIDï¼ˆç©ºãªã‚‰è‡ªå‹•é…ç½®ï¼‰
   *  - focus: ãƒã‚¤ãƒ©ã‚¤ãƒˆå¯¾è±¡ï¼ˆnull ã¾ãŸã¯ {id, mode, depth}ï¼‰
   *
   * æ³¨ï¼šMap/Set ã‚’ä½¿ã†ã“ã¨ã§å­˜åœ¨ãƒã‚§ãƒƒã‚¯ã‚„åˆ—æŒ™ãŒåŠ¹ç‡çš„ã«è¡Œãˆã¾ã™ã€‚
   * ************************************************************************* */
  const state = {
    nodes: new Map(),      // id -> {id, label}
    edges: new Set(),      // "p|c"
    history: [],           // Undo å±¥æ­´ã‚’ç©ã‚€é…åˆ—
    future: [],            // Redo ç”¨ã®ã‚¹ã‚¿ãƒƒã‚¯
    lastId: 0,             // è‡ªå‹•æ¡ç•ªã®ãŸã‚ã®æœ€å¤§æ•°å€¤ID
    direction: 'LR',       // 'LR' or 'TB'
    rootHint: '',          // ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®ãƒ«ãƒ¼ãƒˆãƒ’ãƒ³ãƒˆ
    // ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹: null ã¾ãŸã¯ { id, mode, depth }
    focus: null
  };

  /* ===== ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°ç¾¤ =====
   * - edgeKey / parseEdgeKey: edges Set ç”¨ã®ã‚­ãƒ¼ç”Ÿæˆãƒ»åˆ†è§£
   * - escapeHTML: DOM ã«ç›´æ¥æŒ¿å…¥ã™ã‚‹æ–‡å­—åˆ—ã®ç°¡æ˜“ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—
   * - safeMermaidId / escapeMermaid: Mermaid ãƒ†ã‚­ã‚¹ãƒˆç”¨ã® ID/æ–‡å­—åˆ—æ•´å½¢
   */
  // è¦ªã¨å­ã‚’çµ„ã¿åˆã‚ã›ã¦ä¸€æ„ã®ã‚­ãƒ¼æ–‡å­—åˆ—ã‚’ä½œã‚‹
  const edgeKey = (p,c)=> `${p}|${c}`;
  // ã‚­ãƒ¼æ–‡å­—åˆ—ã‚’ {p,c} ã«æˆ»ã™ï¼ˆsplitï¼‰
  const parseEdgeKey = k => { const [p,c]=k.split('|'); return {p,c}; };
  // ç°¡æ˜“ HTML ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ï¼ˆè¡¨ç¤ºç”¨ãƒ†ã‚­ã‚¹ãƒˆã®å®‰å…¨åŒ–ï¼‰
  const escapeHTML = s => String(s).replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));
  // Mermaid ç”¨ã®å®‰å…¨ãª ID ã‚’ä½œã‚‹ï¼ˆè‹±æ•°å­—/ä¸‹ç·šã®ã¿ï¼‰
  const safeMermaidId = s => 'n' + String(s).replace(/[^a-zA-Z0-9_]/g,'_');
  // Mermaid å†…ã®ç‰¹æ®Šæ–‡å­—ã‚’ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ï¼ˆå¼•ç”¨ç¬¦ç­‰ï¼‰
  const escapeMermaid = s => String(s).replace(/(["'`\\])/g,'\\$1');

  /* ***************************************************************************
   * ãƒãƒ¼ãƒ‰æ“ä½œ
   * ************************************************************************* */
  // è‡ªå‹• ID å‰²å½“ã§ãƒãƒ¼ãƒ‰ã‚’è¿½åŠ ã™ã‚‹
  // label: ãƒãƒ¼ãƒ‰ã®ãƒ©ãƒ™ãƒ«ï¼ˆä»»æ„ï¼‰
  // pushHistory: æ“ä½œå±¥æ­´ã«è¨˜éŒ²ã™ã‚‹ã‹
  function addNodeAuto(label = "", pushHistory = true) {
    // lastId ã‚’åŸºã«æ•°å€¤IDã‚’ã‚¤ãƒ³ã‚¯ãƒªãƒ¡ãƒ³ãƒˆã—ã¦ç©ºãIDã‚’æ¢ã™
    let n = state.lastId;
    while (true) {
      n++;
      const id = String(n);
      if (!state.nodes.has(id)) {
        state.nodes.set(id, { id, label });
        state.lastId = n; // æ¡ç•ªä¸Šé™ã‚’æ›´æ–°
        if (pushHistory) state.history.push({ type: "addNode", node: { id, label } });
        state.future.length = 0; // redo å±¤ã‚’ã‚¯ãƒªã‚¢
        return id;
      }
    }
  }
  // æŒ‡å®š ID ã§ãƒãƒ¼ãƒ‰ã‚’è¿½åŠ ï¼ˆæ‰‹å‹•æŒ‡å®šï¼‰
  function addNodeWithId(id, label = "", pushHistory = true) {
    id = String(id).trim();
    if (!id) return { ok: false, reason: "IDãŒç©ºã§ã™" };
    if (state.nodes.has(id)) return { ok: false, reason: "åŒä¸€IDãŒæ—¢ã«å­˜åœ¨ã—ã¾ã™" };
    state.nodes.set(id, { id, label: String(label || "") });
    // ID ãŒæ•°å€¤ã®å ´åˆã¯ lastId ã‚’æ›´æ–°ã—ã¦è‡ªå‹•æ¡ç•ªã¨è¡çªã—ãªã„ã‚ˆã†ã«ã™ã‚‹
    const num = Number(id);
    if (Number.isFinite(num)) state.lastId = Math.max(state.lastId, num);
    if (pushHistory) state.history.push({ type: "addNode", node: { id, label } });
    state.future.length = 0;
    render();
    return { ok: true, id };
  }
  // ãƒãƒ¼ãƒ‰å‰Šé™¤ã€‚é–¢é€£ã™ã‚‹ã‚¨ãƒƒã‚¸ã‚‚ä½µã›ã¦å‰Šé™¤ã™ã‚‹
  function removeNode(id, pushHistory = true) {
    if (!state.nodes.has(id)) return { ok: false, reason: "ãƒãƒ¼ãƒ‰ãŒå­˜åœ¨ã—ã¾ã›ã‚“" };
    const removedEdges = [];
    // edges ã¯ Set ãªã®ã§ã€å‰Šé™¤ã—ãªãŒã‚‰ removedEdges ã«è¨˜éŒ²
    for (const k of [...state.edges]) {
      const { p, c } = parseEdgeKey(k);
      if (p === id || c === id) { state.edges.delete(k); removedEdges.push({ p, c }); }
    }
    const node = state.nodes.get(id);
    state.nodes.delete(id);
    if (pushHistory) state.history.push({ type: "removeNode", node, removedEdges });
    state.future.length = 0;
    render();
    return { ok: true };
  }
  // ãƒãƒ¼ãƒ‰ã®ãƒ©ãƒ™ãƒ«ã‚’å¤‰æ›´
  function renameNodeLabel(id, newLabel, pushHistory = true) {
    const n = state.nodes.get(id);
    if (!n) return { ok: false, reason: "ãƒãƒ¼ãƒ‰ãŒå­˜åœ¨ã—ã¾ã›ã‚“" };
    const prev = n.label || "";
    n.label = String(newLabel || "");
    if (pushHistory) state.history.push({ type: "renameLabel", id, prev, next: n.label });
    state.future.length = 0;
    render();
    return { ok: true };
  }

  /* ***************************************************************************
   * DAGãƒã‚§ãƒƒã‚¯ & ã‚¨ãƒƒã‚¸æ“ä½œ
   * ************************************************************************* */
  function buildAdj() {
    // å‡ºæ¬¡æ•° / é€†éš£æ¥ãƒªã‚¹ãƒˆã‚’æ§‹ç¯‰ã—ã¦è¿”ã™
    const out = new Map([...state.nodes.keys()].map(id => [id, new Set()]));
    const rev = new Map([...state.nodes.keys()].map(id => [id, new Set()])); // é€†éš£æ¥ï¼ˆç¥–å…ˆæ¢ç´¢ç”¨ï¼‰
    for (const k of state.edges) {
      const { p, c } = parseEdgeKey(k);
      if (!out.has(p)) out.set(p, new Set());
      if (!rev.has(c)) rev.set(c, new Set());
      out.get(p).add(c);
      rev.get(c).add(p);
    }
    return { out, rev };
  }
  function wouldCreateCycle(parent, child) {
    // parent==child ãªã‚‰å³ã‚µã‚¤ã‚¯ãƒ«
    if (parent === child) return true;
    // ä»®ã« parent->child ã‚’è¿½åŠ ã—ãŸã‚°ãƒ©ãƒ•ã§ child ã‹ã‚‰ parent ã«åˆ°é”ã§ãã‚‹ã‹ã‚’ DFS ã§åˆ¤å®š
    const { out } = buildAdj();
    if (!out.has(parent)) out.set(parent, new Set());
    out.get(parent).add(child);
    const target = parent;
    const stack = [child], seen = new Set();
    while (stack.length) {
      const v = stack.pop();
      if (v === target) return true; // åˆ°é”ã—ãŸã‚‰ã‚µã‚¤ã‚¯ãƒ«
      if (seen.has(v)) continue;
      seen.add(v);
      const nxt = out.get(v) || new Set();
      for (const w of nxt) stack.push(w);
    }
    return false;
  }
  function addEdge(parent, child, pushHistory=true) {
    // ã‚¨ãƒƒã‚¸è¿½åŠ ï¼ˆDAG ãƒã‚§ãƒƒã‚¯ãƒ»å­˜åœ¨ãƒã‚§ãƒƒã‚¯ã‚’è¡Œã†ï¼‰
    const k = edgeKey(parent, child);
    if (!state.nodes.has(parent) || !state.nodes.has(child)) return { ok: false, reason: "å­˜åœ¨ã—ãªã„ãƒãƒ¼ãƒ‰ã§ã™" };
    if (state.edges.has(k)) return { ok: false, reason: "åŒä¸€ã®ä¾å­˜ãŒæ—¢ã«ã‚ã‚Šã¾ã™" };
    if (wouldCreateCycle(parent, child)) return { ok: false, reason: "DAGé•åï¼ˆã‚µã‚¤ã‚¯ãƒ«ãŒç™ºç”Ÿï¼‰" };
    state.edges.add(k);
    if (pushHistory) state.history.push({ type: "addEdge", parent, child });
    state.future.length = 0;
    render();
    return { ok: true };
  }
  function removeEdge(parent, child, pushHistory=true) {
    const k = edgeKey(parent, child);
    if (!state.edges.has(k)) return { ok: false, reason: "ä¾å­˜ãŒå­˜åœ¨ã—ã¾ã›ã‚“" };
    state.edges.delete(k);
    if (pushHistory) state.history.push({ type: "removeEdge", parent, child });
    state.future.length = 0;
    render();
    return { ok: true };
  }

  /* ***************************************************************************
   * Undo / Redo
   * ************************************************************************* */
  function undo() {
    // ç›´å‰ã®æ“ä½œã‚’å–ã‚Šå‡ºã—ã¦é€†æ“ä½œã‚’é©ç”¨ã—ã€redo ã‚¹ã‚¿ãƒƒã‚¯ã«ä¿å­˜ã™ã‚‹
    const cmd = state.history.pop(); if (!cmd) return;
    if (cmd.type === "addEdge") {
      state.edges.delete(edgeKey(cmd.parent, cmd.child)); state.future.push(cmd);
    } else if (cmd.type === "removeEdge") {
      state.edges.add(edgeKey(cmd.parent, cmd.child)); state.future.push(cmd);
    } else if (cmd.type === "addNode") {
      // addNode ã® undo ã¯ãƒãƒ¼ãƒ‰å‰Šé™¤ï¼ˆé–¢é€£ã‚¨ãƒƒã‚¸ã‚‚å–ã‚Šé™¤ãï¼‰
      const id = cmd.node.id, removedEdges = [];
      for (const k of [...state.edges]) { const { p, c } = parseEdgeKey(k); if (p === id || c === id) { state.edges.delete(k); removedEdges.push({ p, c }); } }
      state.nodes.delete(id);
      state.future.push({ type: "removeNode", node: cmd.node, removedEdges });
    } else if (cmd.type === "removeNode") {
      // removeNode ã® undo ã¯ãƒãƒ¼ãƒ‰å¾©å…ƒã¨å‰Šé™¤ã—ãŸã‚¨ãƒƒã‚¸ã®å¾©å…ƒ
      state.nodes.set(cmd.node.id, { id: cmd.node.id, label: cmd.node.label || "" });
      for (const e of cmd.removedEdges) state.edges.add(edgeKey(e.p, e.c));
      state.future.push({ type: "addNode", node: cmd.node });
    } else if (cmd.type === "renameLabel") {
      const n = state.nodes.get(cmd.id); if (n) n.label = cmd.prev;
      state.future.push({ type: "renameLabel", id: cmd.id, prev: cmd.next, next: cmd.prev });
    }
    render();
  }
  function redo() {
    // redo ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰ã‚³ãƒãƒ³ãƒ‰ã‚’å–ã‚Šå‡ºã—ã¦å†å®Ÿè¡Œ
    const cmd = state.future.pop(); if (!cmd) return;
    if (cmd.type === "addEdge") { state.edges.add(edgeKey(cmd.parent, cmd.child)); state.history.push(cmd); }
    else if (cmd.type === "removeEdge") { state.edges.delete(edgeKey(cmd.parent, cmd.child)); state.history.push(cmd); }
    else if (cmd.type === "addNode") { state.nodes.set(cmd.node.id, { id: cmd.node.id, label: cmd.node.label || "" }); state.history.push(cmd); }
    else if (cmd.type === "removeNode") {
      const id = cmd.node.id;
      for (const k of [...state.edges]) { const { p, c } = parseEdgeKey(k); if (p === id || c === id) state.edges.delete(k); }
      state.nodes.delete(id); state.history.push(cmd);
    } else if (cmd.type === "renameLabel") { const n = state.nodes.get(cmd.id); if (n) n.label = cmd.next; state.history.push(cmd); }
    render();
  }

  /* ***************************************************************************
   * å…¥å‡ºåŠ›ï¼ˆJSON / Mermaidï¼‰
   * ************************************************************************* */
  function exportJSON() {
    // ç¾åœ¨ã®ãƒãƒ¼ãƒ‰/ã‚¨ãƒƒã‚¸ã‚’ JSON ã«ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã•ã›ã‚‹
    const blob = new Blob([JSON.stringify({ nodes: [...state.nodes.values()], edges: [...state.edges].map(parseEdgeKey) }, null, 2)], { type: "application/json" });
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = "dag.json"; a.click(); URL.revokeObjectURL(a.href);
  }
  function importJSON(obj) {
    // JSON ã‚¤ãƒ³ãƒãƒ¼ãƒˆã€‚ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ã‹ã‚‰ state ã‚’ç½®æ›
    if (!obj || !Array.isArray(obj.nodes) || !Array.isArray(obj.edges)) { alert("ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆä¸æ­£: {nodes:[{id,label}], edges:[{p,c}]}"); return; }
    state.nodes.clear(); state.edges.clear(); state.history.length = 0; state.future.length = 0; state.lastId = 0; state.focus = null;
    for (const n of obj.nodes) {
      const id = String(n.id); state.nodes.set(id, { id, label: n.label ?? "" });
      const num = Number(id); if (Number.isFinite(num)) state.lastId = Math.max(state.lastId, num);
    }
    for (const e of obj.edges) {
      const p = String(e.p), c = String(e.c);
      if (state.nodes.has(p) && state.nodes.has(c) && !wouldCreateCycle(p, c)) state.edges.add(edgeKey(p, c));
    }
    render();
  }
  function mermaidText() {
    const lines=["graph LR"];
    for (const n of state.nodes.values()) lines.push(`  ${safeMermaidId(n.id)}[${escapeMermaid(n.id)}]`);
    for (const k of state.edges) { const {p,c}=parseEdgeKey(k); lines.push(`  ${safeMermaidId(p)} --> ${safeMermaidId(c)}`); }
    return lines.join("\n");
  }

  /* ***************************************************************************
   * åˆæœŸãƒ‡ãƒ¼ã‚¿
   * ************************************************************************* */
  function seed() {
    if (state.nodes.size) return;
    addNodeWithId("S","é–‹å§‹",false);
    addNodeWithId("A","æ‹…å½“æ¥­å‹™A",false);
    addNodeWithId("B","ãƒ¬ãƒ“ãƒ¥ãƒ¼",false);
    addNodeWithId("C","ãƒ†ã‚¹ãƒˆæº–å‚™",false);
    addEdge("S","A",false); addEdge("A","B",false); addEdge("A","C",false);
    render();
  }

  /* ***************************************************************************
   * ç”»é¢ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ï¼ˆå€™è£œãƒªã‚¹ãƒˆ/ä¾å­˜è¡¨/Mermaid/SVGï¼‰
   * ************************************************************************* */
  // DOM è¦ç´ ã¯ä¸€åº¦ã ã‘å–å¾—ã—ã¦å†åˆ©ç”¨ï¼ˆDOM ã‚¯ã‚¨ãƒªã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰å‰Šæ¸›ï¼‰
  const leftList = document.getElementById('leftList');
  const rightList = document.getElementById('rightList');
  const edgeTable = document.getElementById('edgeTable');
  const mermaidTxt = document.getElementById('mermaidTxt');
  const graphSvg = document.getElementById('graphSvg');
  const datalist = document.getElementById('nodeList');

  function render() {
    // --- çµã‚Šè¾¼ã¿ ---
    // filterLeft/filterRight ã¯é »å‡ºãªã®ã§ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã—ã¦ã‚‚è‰¯ã„ãŒç°¡æ½”ã®ãŸã‚ç›´æ¥å‚ç…§
    const fl = document.getElementById('filterLeft').value.trim().toLowerCase();
    const fr = document.getElementById('filterRight').value.trim().toLowerCase();
    const nodeMatch = (n,f)=> !f || n.id.toLowerCase().includes(f) || (n.label||"").toLowerCase().includes(f);

    // --- å€™è£œãƒªã‚¹ãƒˆ ---
    // å€™è£œãƒªã‚¹ãƒˆã®å†æ§‹ç¯‰ï¼ˆå·¦ã¯ãƒ‰ãƒ©ãƒƒã‚°ã§è¦ªé–‹å§‹ã€å³ã¯ãƒ‰ãƒ­ãƒƒãƒ—å…ˆï¼‰
    leftList.innerHTML = ""; rightList.innerHTML = "";
    for (const n of state.nodes.values()) {
      if (nodeMatch(n, fl)) leftList.appendChild(renderItem(n, {draggable:true, role:"parent"}));
      if (nodeMatch(n, fr)) rightList.appendChild(renderItem(n, {draggable:false, role:"child"}));
    }

    // --- datalistæ›´æ–°ï¼ˆãƒã‚¤ãƒ©ã‚¤ãƒˆå…¥åŠ›è£œåŠ©ï¼‰ ---
    // datalist ã‚’æ›´æ–°ã—ã¦å…¥åŠ›è£œåŠ©ã‚’æœ‰åŠ¹ã«ã™ã‚‹
    datalist.innerHTML = "";
    for (const n of state.nodes.values()) {
      const opt = document.createElement('option');
      opt.value = n.id;
      opt.label = n.label ? `${n.id} â€” ${n.label}` : n.id;
      datalist.appendChild(opt);
    }

    // --- ä¾å­˜è¡¨ ---
    // ä¾å­˜è¡¨ã‚’å†æ§‹ç¯‰
    edgeTable.innerHTML = "";
    for (const k of state.edges) {
      const {p,c} = parseEdgeKey(k);
      const pn = state.nodes.get(p), cn = state.nodes.get(c);
      const tr = document.createElement('tr');
      const tdP = document.createElement('td'); tdP.textContent = `${pn?.id ?? p} (${pn?.label ?? ""})`;
      const tdArrow = document.createElement('td'); tdArrow.textContent = "â†’";
      const tdC = document.createElement('td'); tdC.textContent = `${cn?.id ?? c} (${cn?.label ?? ""})`;
      const tdStatus = document.createElement('td'); tdStatus.innerHTML = `<span style="color:var(--ok)">OK</span>`;
      const tdOps = document.createElement('td');
      const btnDel = document.createElement('button'); btnDel.textContent = "å‰Šé™¤"; btnDel.onclick = () => removeEdge(p,c);
      tdOps.appendChild(btnDel);
      tr.append(tdP, tdArrow, tdC, tdStatus, tdOps);
      edgeTable.appendChild(tr);
    }

    // --- Mermaidãƒ†ã‚­ã‚¹ãƒˆ ---
    const mtxt = mermaidText();
    // è‡ªå‹•ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ï¼ˆmermaid ãŒãƒ­ãƒ¼ãƒ‰ã•ã‚Œã¦ã„ã‚‹å ´åˆï¼‰ã€‚å¤±æ•—ã—ã¦ã‚‚ UI ã‚’å£Šã•ãªã„ã€‚
    if (window.mermaid && typeof mermaid.render === 'function') {
      try {
        // mermaid.render ã¯éåŒæœŸã« SVG ã‚’è¿”ã™ã“ã¨ãŒã‚ã‚‹ãŸã‚å®‰å…¨ã«ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
        mermaid.parse(mtxt); // ã¾ãšæ§‹æ–‡ãƒã‚§ãƒƒã‚¯ï¼ˆä¾‹å¤–ãŒå‡ºã‚Œã°ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡¨ç¤ºï¼‰
        const svgId = 'mermaid-' + Date.now();
        mermaid.render(svgId, mtxt, (svgCode) => { mermaidTxt.innerHTML = svgCode; });
      } catch (e) {
        mermaidTxt.textContent = mtxt; // æ§‹æ–‡ã‚¨ãƒ©ãƒ¼ãªã©ã¯ãƒ†ã‚­ã‚¹ãƒˆã§è¡¨ç¤º
      }
    } else {
      mermaidTxt.textContent = mtxt;
    }

    // --- æ°¸ç¶šåŒ– ---
    try {
      const obj = { nodes:[...state.nodes.values()], edges:[...state.edges].map(parseEdgeKey) };
      localStorage.setItem('dag-linker', JSON.stringify(obj));
    } catch(e){}

    // --- SVGå†æç”» ---
    drawSVG();
  }

  // å€™è£œã‚«ãƒ¼ãƒ‰ã®æç”»ï¼ˆDnDï¼‰
  function renderItem(n, {draggable, role}) {
    // ãƒãƒ¼ãƒ‰ä¸€è¦§ã®ã‚¢ã‚¤ãƒ†ãƒ è¦ç´ ã‚’ä½œæˆã—ã¦è¿”ã™
    const el = document.createElement('div'); el.className = 'item' + (draggable ? ' drag-parent' : '');
    el.setAttribute('data-id', n.id); el.setAttribute('data-role', role);

    const left = document.createElement('div'); left.style.display = 'flex'; left.style.flexDirection = 'column';
    left.innerHTML = `<div><strong>${escapeHTML(n.id)}</strong> ${n.label ? `- ${escapeHTML(n.label)}` : ""}</div>` +
      `<div class="meta">${draggable ? 'ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦è¦ªã¨ã—ã¦é–‹å§‹' : 'ãƒ‰ãƒ­ãƒƒãƒ—ã§å­ã¨ã—ã¦ç¢ºå®š'}</div>`;
    const ops=document.createElement('div'); ops.className='ops';
    const editBtn=document.createElement('button'); editBtn.className='icon'; editBtn.title='ãƒ©ãƒ™ãƒ«ç·¨é›†'; editBtn.textContent='âœ';
    editBtn.onclick=()=>{
      const newLabel=prompt(`ãƒ©ãƒ™ãƒ«ã‚’ç·¨é›†: ${n.id}`, n.label||"");
      if (newLabel===null) return; renameNodeLabel(n.id,newLabel);
    };
    const delBtn=document.createElement('button'); delBtn.className='icon'; delBtn.title='ãƒãƒ¼ãƒ‰å‰Šé™¤'; delBtn.textContent='ğŸ—‘';
    delBtn.onclick=()=>{
      if (!confirm(`ãƒãƒ¼ãƒ‰ã€Œ${n.id}ã€ã‚’å‰Šé™¤ã—ã¾ã™ã€‚é–¢é€£ã™ã‚‹ä¾å­˜é–¢ä¿‚ã‚‚å‰Šé™¤ã•ã‚Œã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ`)) return;
      removeNode(n.id);
    };
    ops.append(editBtn,delBtn); el.append(left,ops);

    if (draggable) {
      // è¦ªå€™è£œï¼šãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®š
      el.setAttribute('draggable', 'true');
      el.addEventListener('dragstart', ev => { el.classList.add('dragging'); ev.dataTransfer?.setData('text/plain', n.id); rightList.classList.add('drop-ready'); });
      el.addEventListener('dragend', () => { el.classList.remove('dragging'); rightList.classList.remove('drop-ready'); [...rightList.querySelectorAll('.item')].forEach(x => x.classList.remove('drop-target')); });
      // ã‚¿ãƒƒãƒï¼ˆpointerï¼‰å‘ã‘ã®ç°¡æ˜“å¯¾å¿œ
      el.addEventListener('pointerdown', ev => { el.setPointerCapture(ev.pointerId); el.dataset.draggingPointer = '1'; rightList.classList.add('drop-ready'); });
      el.addEventListener('pointerup', ev => { el.releasePointerCapture?.(ev.pointerId); delete el.dataset.draggingPointer; rightList.classList.remove('drop-ready'); [...rightList.querySelectorAll('.item')].forEach(x => x.classList.remove('drop-target')); });
    } else {
      // å­å€™è£œï¼šãƒ‰ãƒ­ãƒƒãƒ—å…ˆã¨ã—ã¦æŒ¯ã‚‹èˆã†ã‚¤ãƒ™ãƒ³ãƒˆ
      el.addEventListener('dragover', ev => { ev.preventDefault(); el.classList.add('drop-target'); });
      el.addEventListener('dragleave', () => el.classList.remove('drop-target'));
      el.addEventListener('drop', ev => {
        ev.preventDefault(); el.classList.remove('drop-target');
        const parentId = ev.dataTransfer?.getData('text/plain'); if (!parentId) return;
        const r = addEdge(parentId, n.id); if (!r.ok) alert(`è¿½åŠ å¤±æ•—: ${r.reason}`);
      });
      // pointerï¼ˆã‚¿ãƒƒãƒï¼‰ã§ãƒ‰ãƒ­ãƒƒãƒ—ã™ã‚‹ç°¡æ˜“ãƒ­ã‚¸ãƒƒã‚¯
      el.addEventListener('pointerenter', () => { const dragging = leftList.querySelector('.item.dragging') || leftList.querySelector('.item[data-dragging-pointer="1"]'); if (dragging) el.classList.add('drop-target'); });
      el.addEventListener('pointerup', () => { const dragging = leftList.querySelector('.item.dragging') || leftList.querySelector('.item[data-dragging-pointer="1"]'); if (!dragging) return; const parentId = dragging.getAttribute('data-id'); const r = addEdge(parentId, n.id); if (!r.ok) alert(`è¿½åŠ å¤±æ•—: ${r.reason}`); });
    }
    return el;
  }

  /* ***************************************************************************
   * ãƒã‚¤ãƒ©ã‚¤ãƒˆè¨ˆç®—ï¼ˆä¸­å¿ƒIDã‹ã‚‰ä¸Šä¸‹æµ/1-hopã¸ï¼‰
   * ************************************************************************* */
  function computeFocusSets(centerId, mode, depth) {
    // æˆ»ã‚Šå€¤ï¼š{ nodeSet:Set<string>, edgeSet:Set<string> }
    const {out, rev} = buildAdj();
    const nodeSet = new Set([centerId]); // å¸¸ã«ä¸­å¿ƒã‚’å«ã‚€
    const edgeSet = new Set();

    // BFSãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ï¼ˆæ–¹å‘ã¨æ·±ã•ã§æ¢ç´¢ï¼‰
    // BFS ã‚’ä½¿ã£ã¦æŒ‡å®šæ–¹å‘ã«æ·±ã•åˆ¶é™ã¤ãã§æ¢ç´¢ã™ã‚‹ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
    const bfs = (startIds, nextOf, maxDepth) => {
      const q = []; const dist = new Map();
      for (const s of startIds) { q.push(s); dist.set(s, 0); }
      while (q.length) {
        const v = q.shift();
        const d = dist.get(v) ?? 0;
        if (maxDepth !== null && d >= maxDepth) continue; // æ·±ã•åˆ¶é™
        for (const w of nextOf.get(v) || []) {
          if (!dist.has(w)) { dist.set(w, d + 1); q.push(w); }
          nodeSet.add(w);
          // nextOf ãŒ outï¼ˆé †æ–¹å‘ï¼‰ã®å ´åˆã¯ v->wã€revï¼ˆé€†æ–¹å‘ï¼‰ã®å ´åˆã¯ w->v ã¨ã—ã¦ã‚¨ãƒƒã‚¸ã‚’è¿½åŠ 
          const k = nextOf === out ? edgeKey(v, w) : edgeKey(w, v);
          edgeSet.add(k);
        }
      }
    };

    if (mode==='one') {
      // 1-hopï¼šè¦ªã¨å­ã®ã¿
      for (const p of rev.get(centerId) || []) { nodeSet.add(p); edgeSet.add(edgeKey(p,centerId)); }
      for (const c of out.get(centerId) || []) { nodeSet.add(c); edgeSet.add(edgeKey(centerId,c)); }
      return {nodeSet, edgeSet};
    }
    if (mode==='up' || mode==='both') bfs([centerId], rev, depth ?? null);
    if (mode==='down' || mode==='both') bfs([centerId], out, depth ?? null);
    return {nodeSet, edgeSet};
  }

  /* ***************************************************************************
   * SVGæç”»ï¼ˆIDï¼‹ãƒ©ãƒ™ãƒ«è¡¨ç¤ºã€ãƒã‚¤ãƒ©ã‚¤ãƒˆåæ˜ ï¼‰
   * ************************************************************************* */
  let view = { x:0, y:0, w:800, h:600 };
  let bbox = { minX:0, minY:0, maxX:800, maxY:600 };
  const setViewBox = ()=> graphSvg.setAttribute('viewBox', `${view.x} ${view.y} ${view.w} ${view.h}`);

  const ellipsis = (str, maxPx, avgCharPx=7)=> {
    if (!str) return ""; const maxChars = Math.max(1, Math.floor(maxPx / avgCharPx));
    return (str.length<=maxChars) ? str : (str.slice(0, Math.max(0,maxChars-1)) + 'â€¦');
  };

  function computeLayout() {
    const nodes = [...state.nodes.keys()];
    const out = new Map(nodes.map(id=>[id,new Set()])); const inDeg = new Map(nodes.map(id=>[id,0]));
    for (const k of state.edges) { const {p,c}=parseEdgeKey(k); if (!out.has(p)) out.set(p,new Set()); out.get(p).add(c); inDeg.set(c,(inDeg.get(c)||0)+1); }
    // Kahn topo
    const q=[]; for (const id of nodes) if ((inDeg.get(id)||0)===0) q.push(id);
    const topo=[]; while(q.length){ const v=q.shift(); topo.push(v); for (const w of out.get(v)||[]) { inDeg.set(w,(inDeg.get(w)||0)-1); if (inDeg.get(w)===0) q.push(w); } }
    // longest distance ranks (rootHintèµ·ç‚¹ã‚’å„ªå…ˆ)
    const dist = new Map(nodes.map(id=>[id,0])); const hint=state.rootHint.trim();
    if (hint && state.nodes.has(hint)) { for (const id of nodes) dist.set(id, Number.NEGATIVE_INFINITY); dist.set(hint,0); }
    const parents = new Map(nodes.map(id=>[id,new Set()])); for (const k of state.edges) { const {p,c}=parseEdgeKey(k); parents.get(c)?.add(p); }
    for (const v of topo) {
      const ps=parents.get(v)||new Set(); let best=(dist.get(v)===Number.NEGATIVE_INFINITY)?Number.NEGATIVE_INFINITY:0;
      for (const u of ps) { const du=dist.get(u); if (du!==Number.NEGATIVE_INFINITY) best = Math.max(best, du+1); }
      if (best!==Number.NEGATIVE_INFINITY) dist.set(v, Math.max(dist.get(v), best));
    }
    for (const id of nodes) if (dist.get(id)===Number.NEGATIVE_INFINITY) dist.set(id,0);
    const ranks=new Map(); for (const id of nodes) { const r=dist.get(id)||0; if(!ranks.has(r)) ranks.set(r,[]); ranks.get(r).push(id); }
    for (const [r,arr] of ranks) arr.sort((a,b)=> String(a).localeCompare(String(b),'ja'));
    return {ranks};
  }

  function drawSVG() {
    // æ—¢å­˜ï¼ˆdefsé™¤ãï¼‰ã‚¯ãƒªã‚¢
    while (graphSvg.lastChild && graphSvg.lastChild.tagName!=='defs') graphSvg.removeChild(graphSvg.lastChild);

    const {ranks} = computeLayout();
    const dir = state.direction;

  // ãƒãƒ¼ãƒ‰è¦‹ãŸç›®è¨­å®šï¼ˆå¹…/é«˜ã•/é–“éš”ãªã©ï¼‰
  const nodeW = 150, nodeH = 56, hGap = 56, vGap = 28, padX = 10, idFont = 13, labelFont = 12;

    // ä½ç½®è¨ˆç®—
    const pos=new Map(); const rankKeys=[...ranks.keys()].sort((a,b)=>a-b); let maxRows=0;
    rankKeys.forEach((rk,i)=>{
      const arr=ranks.get(rk); maxRows=Math.max(maxRows, arr.length);
      arr.forEach((id,j)=>{ const x=(dir==='LR') ? i*(nodeW+hGap) : j*(nodeW+hGap); const y=(dir==='LR') ? j*(nodeH+vGap) : i*(nodeH+vGap); pos.set(id,{x,y}); });
    });

  // ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®å¹…ã¨é«˜ã•ã‚’è¨ˆç®—
  const contentW = (dir === 'LR') ? (rankKeys.length - 1) * (nodeW + hGap) + nodeW : (maxRows - 1) * (nodeW + hGap) + nodeW;
  const contentH = (dir === 'LR') ? (maxRows - 1) * (nodeH + vGap) + nodeH : (rankKeys.length - 1) * (nodeH + vGap) + nodeH;

    // === ãƒã‚¤ãƒ©ã‚¤ãƒˆå¯¾è±¡é›†åˆã®è¨ˆç®— ===
    let focusNodes=null, focusEdges=null, focusCenter=null;
    if (state.focus && state.nodes.has(state.focus.id)) {
      const depth = (state.focus.depth==null || isNaN(state.focus.depth)) ? null : Math.max(1, Number(state.focus.depth));
      const {nodeSet, edgeSet} = computeFocusSets(state.focus.id, state.focus.mode, depth);
      focusNodes = nodeSet; focusEdges = edgeSet; focusCenter = state.focus.id;
    }

    // --- ã‚¨ãƒƒã‚¸æç”»ï¼ˆèƒŒé¢ï¼‰ ---
    for (const k of state.edges) {
      const {p,c}=parseEdgeKey(k);
      const a=pos.get(p), b=pos.get(c); if (!a||!b) continue;

      // æ–¹å‘ã”ã¨ã®ç«¯ç‚¹
      const srcX = a.x + (dir==='LR' ? nodeW : nodeW/2);
      const srcY = a.y + (dir==='LR' ? nodeH/2 : nodeH);
      const dstX = b.x + (dir==='LR' ? 0 : nodeW/2);
      const dstY = b.y + (dir==='LR' ? nodeH/2 : 0);

      // ãƒ™ã‚¸ã‚§æ›²ç·š
      const dx=Math.max(40, Math.abs(dstX-srcX)*0.5);
      const dy=Math.max(20, Math.abs(dstY-srcY)*0.5);
      const c1x=(dir==='LR')?srcX+dx:srcX, c1y=(dir==='LR')?srcY:srcY+dy;
      const c2x=(dir==='LR')?dstX-dx:dstX, c2y=(dir==='LR')?dstY:dstY-dy;

  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path.setAttribute('d', `M ${srcX} ${srcY} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${dstX} ${dstY}`);
  path.setAttribute('fill', 'none'); path.setAttribute('stroke', 'var(--edge)'); path.setAttribute('stroke-width', '1.5');
  path.setAttribute('marker-end', 'url(#arrow)'); path.setAttribute('opacity', '0.95');

      // ãƒã‚¤ãƒ©ã‚¤ãƒˆé©ç”¨ï¼šå¯¾è±¡ã‚¨ãƒƒã‚¸ãªã‚‰å¼·èª¿ / ãã‚Œä»¥å¤–ã¯dim
      if (focusEdges) {
        if (focusEdges.has(edgeKey(p,c))) path.classList.add('hi-edge');
        else path.classList.add('dim');
      }

      // ã‚¯ãƒªãƒƒã‚¯ã§ã‚¨ãƒƒã‚¸ã‚’å‰Šé™¤ã™ã‚‹ãƒˆã‚°ãƒ«ï¼ˆç¢ºèªãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚ã‚Šï¼‰
      path.addEventListener('click', () => { if (confirm(`ã“ã®ä¾å­˜ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\n${p} â†’ ${c}`)) removeEdge(p, c); });
      graphSvg.appendChild(path);
    }

    // --- ãƒãƒ¼ãƒ‰æç”»ï¼ˆå‰é¢ï¼‰ ---
    for (const [id,p] of pos.entries()) {
      const n = state.nodes.get(id); const label = n?.label || "";

      // ã‚°ãƒ«ãƒ¼ãƒ—
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.setAttribute('transform', `translate(${p.x},${p.y})`);

      // æœ¬ä½“ï¼ˆè§’ä¸¸çŸ©å½¢ï¼‰
      const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
      rect.setAttribute('x','0'); rect.setAttribute('y','0'); rect.setAttribute('width',String(nodeW)); rect.setAttribute('height',String(nodeH));
      rect.setAttribute('rx','8'); rect.setAttribute('ry','8'); rect.setAttribute('fill','#fff'); rect.setAttribute('stroke','#cbd5e1'); rect.setAttribute('stroke-width','1.25');

      // ãƒ†ã‚­ã‚¹ãƒˆ1è¡Œç›®ï¼šID
      const idText = document.createElementNS('http://www.w3.org/2000/svg','text');
      idText.setAttribute('x',String(nodeW/2)); idText.setAttribute('y',String(nodeH/2 - 2)); idText.setAttribute('text-anchor','middle');
      idText.setAttribute('font-size',String(idFont)); idText.setAttribute('font-weight','700'); idText.setAttribute('fill','#0f172a');
      idText.textContent = id;

      // ãƒ†ã‚­ã‚¹ãƒˆ2è¡Œç›®ï¼šãƒ©ãƒ™ãƒ«ï¼ˆçœç•¥â€¦ï¼‰
      const labelText = document.createElementNS('http://www.w3.org/2000/svg','text');
      labelText.setAttribute('x',String(nodeW/2)); labelText.setAttribute('y',String(nodeH/2 + 14)); labelText.setAttribute('text-anchor','middle');
      labelText.setAttribute('font-size',String(labelFont)); labelText.setAttribute('fill','#334155'); labelText.setAttribute('opacity', label?'1':'0.55');
      labelText.textContent = label ? ellipsis(label, nodeW - padX*2, 7) : "(ãƒ©ãƒ™ãƒ«ãªã—)";

  // ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—ï¼ˆtitle è¦ç´ ï¼‰ã‚’ä»˜ä¸
  const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
  title.textContent = label ? `${id} â€” ${label}` : id;

      // ãƒã‚¤ãƒ©ã‚¤ãƒˆé©ç”¨ï¼šfocusNodes ãŒã‚ã‚Œã°å¯¾è±¡å¤–ã‚’æ·¡ãã—ã€å¯¾è±¡ã¯æ ã‚’å¼·èª¿
      if (focusNodes) {
        if (focusNodes.has(id)) {
          rect.classList.add('hi-node');
          if (id === focusCenter) rect.classList.add('hi-center');
        } else {
          g.classList.add('dim');
        }
      }

  // ãƒ›ãƒãƒ¼è£…é£¾ï¼ˆç°¡æ˜“ï¼‰
  g.addEventListener('mouseenter', () => { rect.style.stroke = '#06b6d4'; rect.style.strokeWidth = '2'; });
  g.addEventListener('mouseleave', () => { rect.style.stroke = focusNodes && focusNodes.has(id) ? rect.style.stroke : '#cbd5e1'; rect.style.strokeWidth = focusNodes && focusNodes.has(id) ? rect.style.strokeWidth : '1.25'; });

      // ã‚¯ãƒªãƒƒã‚¯ï¼šã“ã®ãƒãƒ¼ãƒ‰ã‚’ä¸­å¿ƒã«ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆç¾åœ¨ã®ãƒ¢ãƒ¼ãƒ‰/æ·±ã•ã‚’åˆ©ç”¨ï¼‰
      g.addEventListener('click', ()=>{
        const mode = document.getElementById('focusMode').value;
        const depthStr = document.getElementById('focusDepth').value.trim();
        const depth = depthStr==="" ? null : Number(depthStr);
        state.focus = { id, mode, depth: (depth==null || isNaN(depth)) ? null : depth };
        // å…¥åŠ›æ¬„ã¸åæ˜ 
        document.getElementById('focusId').value = id;
        drawSVG();
      });

      g.append(rect,idText,labelText,title);
      graphSvg.appendChild(g);
    }

    // bboxæ›´æ–° & åˆæœŸviewBox
    bbox = {minX:0,minY:0,maxX:contentW,maxY:contentH};
    if (!graphSvg.hasAttribute('viewBox')) {
      view = { x:0, y:0, w:Math.max(800, contentW+80), h:Math.max(600, contentH+80) };
      setViewBox();
    }
  }

  /* ***************************************************************************
   * ãƒ‘ãƒ³/ã‚ºãƒ¼ãƒ ãƒ»ãƒ•ã‚£ãƒƒãƒˆãƒ»SVGã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
   * ************************************************************************* */
  (function(){
    let isPanning=false, start={x:0,y:0}, startView={x:0,y:0};
    // ãƒã‚¦ã‚¹ãƒ‰ãƒ©ãƒƒã‚°ã§ãƒ‘ãƒ³ã€ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ ã‚’å®Ÿè£…
    graphSvg.addEventListener('mousedown', ev => { isPanning = true; start = { x: ev.clientX, y: ev.clientY }; startView = { ...view }; });
    window.addEventListener('mousemove', ev => {
      if (!isPanning) return;
      const dx = (ev.clientX - start.x) * (view.w / graphSvg.clientWidth);
      const dy = (ev.clientY - start.y) * (view.h / graphSvg.clientHeight);
      view.x = startView.x - dx; view.y = startView.y - dy; setViewBox();
    });
    window.addEventListener('mouseup', () => { isPanning = false; });
    graphSvg.addEventListener('wheel', ev => {
      ev.preventDefault();
      const scale = (ev.deltaY < 0) ? 0.9 : 1.1;
      const mx = ev.offsetX / graphSvg.clientWidth; const my = ev.offsetY / graphSvg.clientHeight;
      const vx = view.x + view.w * mx; const vy = view.y + view.h * my;
      view.w *= scale; view.h *= scale;
      view.x = vx - view.w * mx; view.y = vy - view.h * my; setViewBox();
    }, { passive: false });
  })();

  document.getElementById('fitBtn').onclick = ()=>{
    const pad=40;
    view = { x:Math.max(0,bbox.minX)-pad, y:Math.max(0,bbox.minY)-pad, w:(bbox.maxX-bbox.minX)+pad*2, h:(bbox.maxY-bbox.minY)+pad*2 };
    setViewBox();
  };
  document.getElementById('exportSvgBtn').onclick = ()=>{
    const clone = graphSvg.cloneNode(true); clone.setAttribute('xmlns','http://www.w3.org/2000/svg');
    const s = new XMLSerializer().serializeToString(clone);
    const blob = new Blob([s], {type:'image/svg+xml'});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='dag.svg'; a.click(); URL.revokeObjectURL(a.href);
  };

  // æç”»ã‚ªãƒ—ã‚·ãƒ§ãƒ³
  document.getElementById('directionSel').addEventListener('change', e=>{ state.direction=e.target.value; graphSvg.removeAttribute('viewBox'); drawSVG(); document.getElementById('fitBtn').click(); });
  document.getElementById('rootHint').addEventListener('change', e=>{ state.rootHint=e.target.value.trim(); graphSvg.removeAttribute('viewBox'); drawSVG(); document.getElementById('fitBtn').click(); });

  /* ***************************************************************************
   * ãƒã‚¤ãƒ©ã‚¤ãƒˆæ“ä½œï¼ˆUIï¼‰
   * ************************************************************************* */
  document.getElementById('applyFocusBtn').onclick = ()=>{
    const id = document.getElementById('focusId').value.trim();
    if (!id || !state.nodes.has(id)) { alert('å­˜åœ¨ã™ã‚‹ä¸­å¿ƒIDã‚’æŒ‡å®šã—ã¦ãã ã•ã„'); return; }
    const mode = document.getElementById('focusMode').value;
    const depthStr = document.getElementById('focusDepth').value.trim();
    const depth = depthStr==="" ? null : Number(depthStr);
    state.focus = { id, mode, depth:(depth==null||isNaN(depth))?null:depth };
    drawSVG();
  };
  document.getElementById('clearFocusBtn').onclick = ()=>{ state.focus=null; document.getElementById('focusId').value=""; drawSVG(); };
  // Escã‚­ãƒ¼ã§è§£é™¤
  window.addEventListener('keydown', e=>{ if (e.key==='Escape') { state.focus=null; document.getElementById('focusId').value=""; drawSVG(); } });

  /* ***************************************************************************
   * å…±é€šUIï¼ˆUndo/Redoãƒ»å…¥å‡ºåŠ›ãƒ»ãƒªã‚»ãƒƒãƒˆãƒ»ãƒ•ã‚£ãƒ«ã‚¿ï¼‰
   * ************************************************************************* */
  document.getElementById('undoBtn').onclick=undo;
  document.getElementById('redoBtn').onclick=redo;
  document.getElementById('exportBtn').onclick=exportJSON;
  document.getElementById('importBtn').onclick=()=> document.getElementById('fileInput').click();
  document.getElementById('fileInput').addEventListener('change', e=>{
    const f=e.target.files?.[0]; if (!f) return;
    const fr=new FileReader(); fr.onload=()=>{ try{ importJSON(JSON.parse(fr.result)); }catch{ alert("JSONèª­å–ã‚¨ãƒ©ãƒ¼"); } }; fr.readAsText(f);
  });
  document.getElementById('clearBtn').onclick=()=>{
    if (!confirm("å…¨ãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ")) return;
    state.nodes.clear(); state.edges.clear(); state.history.length=0; state.future.length=0; state.focus=null;
    localStorage.removeItem('dag-linker');
    seed(); graphSvg.removeAttribute('viewBox'); drawSVG(); document.getElementById('fitBtn').click();
  };
  document.getElementById('filterLeft').addEventListener('input', render);
  document.getElementById('filterRight').addEventListener('input', render);

  // ===== ãƒãƒ¼ãƒ‰è¿½åŠ ãƒœã‚¿ãƒ³ï¼ˆå˜ä½“ï¼ä¸€æ‹¬ï¼‰ =====
  document.getElementById('addNodeBtn').addEventListener('click', ()=>{
    const id = document.getElementById('newId').value.trim();
    const label = document.getElementById('newLabel').value.trim();
    if (id) {
      const r = addNodeWithId(id, label);
      if (!r.ok) { alert(`è¿½åŠ å¤±æ•—: ${r.reason}`); return; }
    } else {
      addNodeAuto(label);
    }
    // å…¥åŠ›ã‚¯ãƒªã‚¢ã¨å†æç”»
    document.getElementById('newId').value = ""; document.getElementById('newLabel').value = "";
    render();
  });

  document.getElementById('bulkAddBtn').addEventListener('click', ()=>{
    const txt = document.getElementById('bulkText').value.trim(); if (!txt) return;
    // å„è¡Œã‚’è§£æ: ID,Label ã¾ãŸã¯ ID<TAB>Label ã¾ãŸã¯ ID ã®ã¿
    const lines = txt.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
    let added=0;
    for (const line of lines) {
      const m = line.split(/\s*,\s*|\t/); // ã‚«ãƒ³ãƒã¾ãŸã¯ã‚¿ãƒ–ã§åˆ†å‰²
      const id = m[0]?.trim(); const label = (m[1]||"").trim();
      if (!id) continue;
      const r = addNodeWithId(id, label);
      if (!r.ok) {
        // æ—¢å­˜IDã§å¤±æ•—ã—ãŸå ´åˆã¯è‡ªå‹•è¿½åŠ ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã—ãªã„ã€‚ãƒ¦ãƒ¼ã‚¶ã«é€šçŸ¥ã—ã¦å‡¦ç†ç¶šè¡Œ
        console.warn(`bulk add skipped ${id}: ${r.reason}`);
        continue;
      }
      added++;
    }
    if (added) render();
  });

  document.getElementById('bulkClearBtn').addEventListener('click', ()=>{ document.getElementById('bulkText').value = ""; });

  // Enter ã‚­ãƒ¼ã§è¿½åŠ ï¼ˆnewLabel ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§ Enter ã‚’æŠ¼ã—ã¦ã‚‚è¿½åŠ ã§ãã‚‹ï¼‰
  const newIdEl = document.getElementById('newId');
  const newLabelEl = document.getElementById('newLabel');
  const bulkTextEl = document.getElementById('bulkText');
  newIdEl.addEventListener('keydown', e=>{ if (e.key==='Enter') { e.preventDefault(); document.getElementById('addNodeBtn').click(); } });
  newLabelEl.addEventListener('keydown', e=>{ if (e.key==='Enter') { e.preventDefault(); document.getElementById('addNodeBtn').click(); } });

  // bulkAddBtn ã¯ãƒ†ã‚­ã‚¹ãƒˆãŒç„¡ã„ã¨ç„¡åŠ¹åŒ–
  const bulkAddBtn = document.getElementById('bulkAddBtn');
  const updateBulkBtn = ()=> bulkAddBtn.disabled = !bulkTextEl.value.trim();
  bulkTextEl.addEventListener('input', updateBulkBtn); updateBulkBtn();

  // ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£: ãƒœã‚¿ãƒ³ã« aria-label ã‚’è¿½åŠ ï¼ˆæ—¢ã«è¦‹ãŸç›®ã§ã‚ã‹ã‚‹ãŒè£œåŠ©ï¼‰
  document.getElementById('addNodeBtn').setAttribute('aria-label', 'å˜ä¸€ãƒãƒ¼ãƒ‰è¿½åŠ ');
  bulkAddBtn.setAttribute('aria-label', 'ä¸€æ‹¬ãƒãƒ¼ãƒ‰è¿½åŠ ');
  document.getElementById('bulkClearBtn').setAttribute('aria-label', 'ä¸€æ‹¬å…¥åŠ›ã‚¯ãƒªã‚¢');

  // ãƒ‰ãƒ©ãƒƒã‚°æ™‚ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ Ghost ç”»åƒã‚’æŠ‘åˆ¶ï¼ˆUXå‘ä¸Šï¼‰
  document.addEventListener('dragstart', ev=>{ if (ev.dataTransfer) { try{ ev.dataTransfer.setDragImage(document.createElement('div'),0,0); }catch(e){} } }, true);

  /* ***************************************************************************
   * åˆæœŸåŒ–ï¼ˆä¿å­˜æ¸ˆã¿ â†’ å¾©å…ƒ or ã‚·ãƒ¼ãƒ‰ï¼‰
   * ************************************************************************* */
  try { const raw=localStorage.getItem('dag-linker'); if (raw) importJSON(JSON.parse(raw)); } catch {}
  if (state.nodes.size===0) seed();
  setTimeout(()=> document.getElementById('fitBtn').click(), 0);
})();
</script>
</body>
</html>
